// Copyright (c) 2023-2024 Pierre G. Boutquin. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License").
//  You may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
namespace Boutquin.Trading.Application.EventHandlers;

/// <summary>
/// The SignalEventHandler class is an implementation of the IEventHandler interface that handles SignalEvent objects.
/// SignalEvent objects represent the trading signals generated by a trading strategy.
/// </summary>
/// <remarks>
/// This class handles SignalEvent objects by computing the position sizes for the assets based on the signals,
/// and generating OrderEvent objects for each asset. The OrderEvent objects are then passed to the EventProcessor for further processing.
/// The IPortfolio object that is passed to the SignalEventHandler constructor is used to get the strategy and the historical market data.
/// 
/// Here is an example of how to use this class:
/// <code>
/// var portfolio = new Portfolio();
/// var signalEventHandler = new SignalEventHandler(portfolio);
/// 
/// var signalEvent = new SignalEvent();
/// await signalEventHandler.HandleEventAsync(signalEvent);
/// </code>
/// </remarks>
public sealed class SignalEventHandler : IEventHandler
{
    private readonly IPortfolio _portfolio;

    /// <summary>
    /// Initializes a new instance of the SignalEventHandler class.
    /// </summary>
    /// <param name="portfolio">The portfolio that the signals will be applied to.</param>
    /// <exception cref="ArgumentNullException">Thrown when portfolio is null.</exception>
    public SignalEventHandler(IPortfolio portfolio)
    {
        Guard.AgainstNull(() => portfolio); // Throws ArgumentNullException

        _portfolio = portfolio;
    }

    /// <summary>
    /// Handles the provided SignalEvent object.
    /// </summary>
    /// <param name="eventObj">The SignalEvent object to handle.</param>
    /// <exception cref="ArgumentException">Thrown when eventObj is not a SignalEvent object.</exception>
    /// <returns>A Task representing the asynchronous operation.</returns>
    /// <remarks>
    /// The HandleEventAsync method computes the position sizes for the assets based on the signals,
    /// and generates OrderEvent objects for each asset. The OrderEvent objects are then passed to the EventProcessor for further processing.
    /// The portfolio is retrieved from the portfolio that was passed to the SignalEventHandler constructor.
    /// </remarks>
    public async Task HandleEventAsync(IFinancialEvent eventObj)
    {
        var signalEvent = eventObj as SignalEvent
            ?? throw new ArgumentException("Event must be of type SignalEvent.", nameof(eventObj));

        // Call methods on the Portfolio class to perform the necessary actions
        var strategy = _portfolio.GetStrategy(signalEvent.StrategyName);

        // Compute the position sizes for the assets based on the signals.
        var positionSizes = strategy.PositionSizer.ComputePositionSizes(
            signalEvent.Timestamp,
            signalEvent.Signals,
            strategy,
            _portfolio.HistoricalMarketData,
            _portfolio.HistoricalFxConversionRates);

        // Iterate through the assets and generate OrderEvents for each asset.
        foreach (var asset in signalEvent.Signals.Keys)
        {
            // Get the desired position size for the current asset.
            var desiredPositionSize = positionSizes[asset];

            // Get the current position size for the current asset.
            var currentPositionSize = strategy.Positions.GetValueOrDefault(asset, 0);

            // Calculate the order size based on the difference between the desired position size and the current position size.
            var orderSize = desiredPositionSize - currentPositionSize;

            // If the order size is zero, no order needs to be placed.
            if (orderSize == 0)
            {
                continue;
            }

            // Determine the trade action based on the order size.
            var tradeAction = orderSize > 0 ? TradeAction.Buy : TradeAction.Sell;

            // Calculate the order prices for the current asset.
            var (orderType, primaryPrice, secondaryPrice) =
                strategy.OrderPriceCalculationStrategy.CalculateOrderPrices(
                    signalEvent.Timestamp,
                    asset,
                    tradeAction,
                    _portfolio.HistoricalMarketData);

            // Create an OrderEvent for the current asset.
            var orderEvent = new OrderEvent(
                signalEvent.Timestamp,
                signalEvent.StrategyName,
                asset,
                tradeAction,
                orderType,
                Math.Abs(orderSize),
                primaryPrice,
                secondaryPrice);

            // Pass the OrderEvent to the EventProcessor for further processing.
            await _portfolio.EventProcessor.ProcessEventAsync(orderEvent);
        }
    }
}
